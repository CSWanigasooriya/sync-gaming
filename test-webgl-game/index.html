<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebGL Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="info">
        <h1>ðŸŽ® Simple WebGL Cube</h1>
        <p>Rotating 3D Cube Demo</p>
    </div>
    <div id="controls">
        <p>This is a test WebGL game. The cube rotates automatically.</p>
    </div>

    <script>
        // Get canvas and WebGL context
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported by your browser!');
            throw new Error('WebGL not supported');
        }

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Vertex shader
        const vertexShaderSource = `
            attribute vec3 position;
            attribute vec3 color;
            
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 modelMatrix;
            
            varying vec3 fragColor;
            
            void main() {
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
                fragColor = color;
            }
        `;

        // Fragment shader
        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec3 fragColor;
            
            void main() {
                gl_FragColor = vec4(fragColor, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                throw new Error('Shader compilation failed');
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
            throw new Error('Program linking failed');
        }

        gl.useProgram(program);

        // Cube vertices and colors
        const vertices = [
            // Front face
            -1, -1,  1,    1, -1,  1,    1,  1,  1,   -1,  1,  1,
            // Back face
            -1, -1, -1,   -1,  1, -1,    1,  1, -1,    1, -1, -1,
            // Top face
            -1,  1, -1,   -1,  1,  1,    1,  1,  1,    1,  1, -1,
            // Bottom face
            -1, -1, -1,    1, -1, -1,    1, -1,  1,   -1, -1,  1,
            // Right face
             1, -1, -1,    1,  1, -1,    1,  1,  1,    1, -1,  1,
            // Left face
            -1, -1, -1,   -1, -1,  1,   -1,  1,  1,   -1,  1, -1
        ];

        const colors = [
            // Front face - Red
            1, 0, 0,    1, 0, 0,    1, 0, 0,    1, 0, 0,
            // Back face - Green
            0, 1, 0,    0, 1, 0,    0, 1, 0,    0, 1, 0,
            // Top face - Blue
            0, 0, 1,    0, 0, 1,    0, 0, 1,    0, 0, 1,
            // Bottom face - Yellow
            1, 1, 0,    1, 1, 0,    1, 1, 0,    1, 1, 0,
            // Right face - Cyan
            0, 1, 1,    0, 1, 1,    0, 1, 1,    0, 1, 1,
            // Left face - Magenta
            1, 0, 1,    1, 0, 1,    1, 0, 1,    1, 0, 1
        ];

        const indices = [
            0, 1, 2,    0, 2, 3,      // Front
            4, 5, 6,    4, 6, 7,      // Back
            8, 9, 10,   8, 10, 11,    // Top
            12, 13, 14, 12, 14, 15,   // Bottom
            16, 17, 18, 16, 18, 19,   // Right
            20, 21, 22, 20, 22, 23    // Left
        ];

        // Create buffers
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Enable vertex attributes
        const positionAttr = gl.getAttribLocation(program, 'position');
        const colorAttr = gl.getAttribLocation(program, 'color');

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(positionAttr, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttr);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(colorAttr, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorAttr);

        // Matrix utilities
        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }

        function identity() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }

        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }

        function rotateX(matrix, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const r = new Float32Array([
                1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1
            ]);
            return multiply(matrix, r);
        }

        function rotateY(matrix, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const r = new Float32Array([
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ]);
            return multiply(matrix, r);
        }

        // Get uniform locations
        const projMatrix = gl.getUniformLocation(program, 'projectionMatrix');
        const viewMatrix = gl.getUniformLocation(program, 'viewMatrix');
        const modelMatrix = gl.getUniformLocation(program, 'modelMatrix');

        // Set up lighting
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.1, 0.1, 0.1, 1.0);

        let angle = 0;

        // Render loop
        function render() {
            angle += 0.01;

            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set matrices
            const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
            const view = identity();
            let model = identity();
            model = rotateX(model, angle);
            model = rotateY(model, angle * 0.7);

            gl.uniformMatrix4fv(projMatrix, false, proj);
            gl.uniformMatrix4fv(viewMatrix, false, view);
            gl.uniformMatrix4fv(modelMatrix, false, model);

            // Draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        render();

        // Log successful initialization
        console.log('âœ… WebGL Cube loaded successfully!');
    </script>
</body>
</html>
